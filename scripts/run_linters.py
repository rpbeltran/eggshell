#!/usr/bin/python3

import argparse
import json
import subprocess

def read_compile_commands(build_dir):
    with open(f'{build_dir}/compile_commands.json') as f:
        return json.load(f)


def convert_clang_args(args, build_dir):
    interested_in = [
        "-std",
    ]
    tidy_flags = []
    cc_files = []

    interested = False
    is_cc_file = False

    for arg in args:
        if arg.startswith("-"):
            if arg == "-c":
                interested = False
                is_cc_file = True
            else:
                is_cc_file = False
                interested = any(arg.startswith(interesting_flag) for interesting_flag in interested_in)
            if interested:
                tidy_flags.append("--extra-arg=" + arg)
        elif interested:
            tidy_flags[-1] = tidy_flags[-1] + "=" + arg
            interested = False
        elif is_cc_file:
            cc_files.append(arg)

    return tidy_flags + ["-p", build_dir, "-header-filter=.*"] + cc_files





def invoke_tidy_for(clang_invocation, build_dir):
    clang_args = clang_invocation['command'].split(" ")[1:]
    command = ["clang-tidy"] + convert_clang_args(clang_args, build_dir)

    subprocess.Popen(
        command,
        cwd=clang_invocation['directory'],
    )




def parse_args():
    parser = argparse.ArgumentParser("run_linters")
    parser.add_argument(
        "build_dir",
        help="path to build directory containing compile_commands.json generated by cmake.",
        type=str
    )
    return parser.parse_args()


def main():
    args = parse_args()
    commands = read_compile_commands(args.build_dir)
    for command in commands:
        if not command['output'].startswith("_deps"):
            invoke_tidy_for(command, args.build_dir)


main()