a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x

a | b | c
a | b | c
foo -ef bf c | wow
`foo -ef bf c "d e"` | `wow`
do {}
1 < 2 <= 3 == 3 != 4 >= 4 > 0
not true or false and true or false xor true
do { 1 ** -3 + 4 * 5 - 6 // 7 / 8 % 9 }
1 ** 3 + 4 * 5 - 6 // 7 / 8 % 9 + -1
@foo
@foo::bar::a
@foo::bar::a.b.c.d
do { foo }
do { foo::bar::a }
do { foo::bar::a.b.c.d }
a $ @b + 1 $ c
fn foo(){
    a := b
    ret 1
}
fn foo(a, b: int, c:int=4){
    r := a+b+c
    ret r
}
fn foo(){}
a := 1
a : int = 1
a : t[g] = [1]
a = @b
[1,2,3+3,4,5]
@a[i] + @b[j]
@a[i:j]
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    d

    fn my_method(){

    }
}
class Cow : Animal {}
{1: 10, "b": "b0", l: [1], m:{} }
{}
a && b && c || do {a; b; c}
try{`x`}
try{`x`} catch {`y`}
try{`x`} catch e {`y`}
try{`x`} catch e: t {`y`}
~(`foo`)
~ { `foo`; `bar` }
~(`foo`).x
@a().x
@a[i:j by k]
[i..j]
(i..j)
a | \x -> y
a | \x {a;b}
a | \() -> x
a | \(a, b:int, c:int=1) -> x
a | \x -> @x.b... | c
loop {x(); y()}
loop {}
loop as x {y}
while(a == b) {x(); y()}
while(a == b) {}
while(a == b) as x {y}
for i in l {x(); y()}
for i in [1,2,3] {}
for i in [0..1] as x {y}
(((1 + 2)+((3))+4))
module_name::a.b(1)
import "a.egg"
class thing {
    a: b
    c
    fn my_method(){
    }
}
