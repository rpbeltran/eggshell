?start: top_level_expression


# -- Expressions --

?top_level_expression: write_to_file SEMICOLON?
                     | append_to_file SEMICOLON?
                     | declaration SEMICOLON?
                     | top_level_atomic SEMICOLON?
                     | try_catch
                     | if
                     | define_function

?top_level_atomic: pipeline | expression

?expression: arithmetic | comparison
?atomic: exec
       | paren_expr
       | identifier
       | QUOTED_STRING
       | lambda_func
       | number
       | logical_sequence
       | curried_func
       | boolean_literal
?paren_expr: "PAREN_OPEN" top_level_atomic "PAREN_CLOSE"


# -- Identifiers and Namespaces --

identifier: (NAME "NAMESPACE")* NAME


# -- Variable Declaration --

?declaration: typed_declaration | untyped_declaration

typed_declaration: identifier "COLON" identifier "ASSIGN" expression
untyped_declaration: identifier "DECLARE" expression


# -- File Redirection --

write_to_file: pipeline "ANGLE_CLOSE" (EXEC_ARG | identifier | QUOTED_STRING)
append_to_file: pipeline "APPEND_FILE" (EXEC_ARG | identifier | QUOTED_STRING)


# -- Integer Arithmetic --

?arithmetic: addition | subtraction | arithmetic_2
?arithmetic_2: multiply | divide | int_divide | modulus | arithmetic_3
?arithmetic_3: raise_power | atomic

addition: arithmetic_2 "PLUS" arithmetic_2
subtraction: arithmetic_2 "MINUS" arithmetic_2

multiply: arithmetic_3 "TIMES" arithmetic_3
divide: arithmetic_3 "DIVIDE" arithmetic_3
int_divide: arithmetic_3 "INT_DIV" arithmetic_3
modulus: arithmetic_3 "MOD" arithmetic_3

raise_power: atomic "POWER" atomic

number: INTEGER | FLOAT


# -- Boolean Arithmetic --

?boolean_literal: FALSE | TRUE

?comparison: cmp_equal | cmp_gte | cmp_lte | cmp_gt | cmp_lt

cmp_equal: arithmetic "EQUALS" arithmetic
cmp_gte: arithmetic "GTE" arithmetic
cmp_lte: arithmetic "LTE" arithmetic
cmp_gt: arithmetic "ANGLE_OPEN" arithmetic
cmp_lt: arithmetic "ANGLE_CLOSE" arithmetic


# -- If / Else --

if: "IF" atomic block elif* else?
elif: "ELSE" "IF" atomic block
else: "ELSE" block


# -- Pipelines --

exec: EXEC_ARG+
?pipeline: atomic ("PIPE" atomic)+


# -- Code Blocks --

block: "CURLY_OPEN" top_level_expression* "CURLY_CLOSE"


# -- Error Handling --

try_catch: "TRY" block "CATCH" block
logical_sequence: and_sequence | or_sequence
and_sequence: atomic "SEQ_AND" atomic
or_sequence:  atomic "SEQ_OR" atomic


# -- Functions --

define_function : "FN" NAME func_arglist func_type? func_block

?func_arglist : "PAREN_OPEN" (func_arg ("COMMA" func_arg)*)? "PAREN_CLOSE"
?func_arg: NAME (COLON identifier)? (ASSIGN expression)?
?func_type: "COLON" atomic

func_block: "CURLY_OPEN" (top_level_expression | return_expr)* "CURLY_CLOSE"
return_expr : "RETURN" expression "SEMICOLON"?

# -- Lambdas --

lambda_func: "LAMBDA" (func_arglist | func_arg) "ARROW" lambda_body
?lambda_body: expression | func_block


# -- Currying --

curried_func: atomic ("CURRY" atomic)+


# -- Lexer Declarations --

# - DFA Tokens

%declare EXEC_ARG
%declare FLOAT
%declare NAME
%declare INTEGER
%declare QUOTED_STRING

# - Operators

%declare DECLARE
%declare APPEND_FILE
%declare INT_DIV
%declare COLON
%declare ASSIGN
%declare PIPE
%declare ARROW
%declare LAMBDA
%declare COMMA
%declare NAMESPACE
%declare PAREN_OPEN
%declare PAREN_CLOSE
%declare CURLY_OPEN
%declare CURLY_CLOSE
%declare ANGLE_OPEN # todo: support generics in types
%declare ANGLE_CLOSE # todo: support generics in types
%declare SQUARE_OPEN # todo: support array access
%declare SQUARE_CLOS # todo: support array access
%declare EQUALS
%declare GTE
%declare LTE
%declare SEMICOLON
%declare CURRY
%declare PLUS
%declare MINUS
%declare DIVIDE
%declare TIMES
%declare MOD
%declare POWER
%declare SEQ_AND
%declare SEQ_OR

# - Keywords

%declare FN
%declare FOR # todo: support for loops
%declare WHILE # todo: support while loops
%declare CONTINUE # todo: support CONTINUE in loop bodies
%declare BREAK # todo: support BREAK in loop bodies
%declare TRUE
%declare FALSE
%declare AND # todo: support boolean arithmetic
%declare OR # todo: support boolean arithmetic
%declare XOR # todo: support boolean arithmetic
%declare NOT # todo: support boolean arithmetic
%declare RETURN
%declare IF
%declare ELSE
%declare USE
%declare TRY
%declare CATCH
