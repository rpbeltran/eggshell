?start: top_level_expression


# -- Top Level --

?top_level_expression: write_to_file "SEMICOLON"?
                     | append_to_file "SEMICOLON"?
                     | non_atomic "SEMICOLON"?
                     | try_catch
                     | if
                     | loop
                     | define_function
                     | continue_expr
                     | break_expr
                     | return_expr

?non_atomic: pipeline | expression | declaration


# -- Atomics --

?atomic: exec
       | paren_expr
       | identifier
       | select
       | QUOTED_STRING
       | lambda_func
       | INTEGER
       | FLOAT
       | TRUE
       | FALSE
       | logical_sequence
       | curried_func
       | list
       | map
       | range

?paren_expr: "PAREN_OPEN" non_atomic "PAREN_CLOSE"


# -- Identifiers and Namespaces --

identifier: (NAME "NAMESPACE")* NAME


# -- Variable Assignment And Declaration --

?declaration: declare_typed_variable
            | declare_untyped_variable
            | declare_typed_constant
            | declare_untyped_constant

declare_typed_variable: "VAR"? NAME "COLON" identifier "ASSIGN" expression
declare_untyped_variable: "VAR"? NAME "DECLARE" expression

declare_typed_constant: "CONST" NAME "COLON" identifier "ASSIGN" expression
declare_untyped_constant: "CONST" NAME "DECLARE" expression

assign_variable: identifier "ASSIGN" expression


# -- Lists --

list: "SQUARE_OPEN" _list_inner? "SQUARE_CLOSE"
_list_inner: expression ("COMMA" expression)*

range: "SQUARE_OPEN" _range_inner "SQUARE_CLOSE"
     | "PAREN_OPEN" _range_inner "PAREN_CLOSE"
_range_inner: expression "RANGE" expression


# -- Maps --

map: "CURLY_OPEN" _map_inner "CURLY_CLOSE"
_map_inner: map_entry ("COMMA" map_entry)*
map_entry: expression "COLON" expression


# -- File Redirection --

write_to_file: pipeline "ANGLE_CLOSE" (EXEC_ARG | identifier | QUOTED_STRING)
append_to_file: pipeline "APPEND_FILE" (EXEC_ARG | identifier | QUOTED_STRING)


# -- If / Else --

if: "IF" atomic block elif* else?
elif: "ELSE" "IF" atomic block | "ELIF" atomic block
else: "ELSE" block


# -- Pipelines --

exec: EXEC_ARG+
?pipeline: atomic ("PIPE" atomic)+


# -- Code Blocks --

block: "CURLY_OPEN" top_level_expression* "CURLY_CLOSE"


# -- Error Handling --

try_catch: "TRY" block "CATCH" block
logical_sequence: and_sequence | or_sequence
and_sequence: atomic "SEQ_AND" atomic
or_sequence:  atomic "SEQ_OR" atomic


# -- Functions --

define_function : "FN" NAME func_arglist func_type? block

func_arglist : "PAREN_OPEN" (func_arg ("COMMA" func_arg)*)? "PAREN_CLOSE"
?func_arg: NAME (arg_type)? (arg_default)?
arg_type: "COLON" atomic
arg_default: "ASSIGN" expression
?func_type: "COLON" atomic

return_expr : "RETURN" expression


# -- Lambdas --

lambda_func: "LAMBDA" (func_arglist | func_arg) "ARROW" lambda_body
?lambda_body: expression | block


# -- Currying --

curried_func: atomic ("CURRY" atomic)+


# -- Loops --

?loop: always_loop | for | while
always_loop: "ALWAYS_LOOP" label? block
for: "FOR" NAME "IN" expression label? block
while: "WHILE" expression label? block

label: "AS" NAME

continue_expr : "CONTINUE" NAME?
break_expr : "BREAK" NAME?


# -- Arithmetic --

?expression: arithmetic_or

# --- Disjunction

?arithmetic_or: or_expr | xor_expr | arithmetic_and

or_expr: arithmetic_and "OR" arithmetic_and
xor_expr: arithmetic_and "XOR" arithmetic_and

# --- Conjunction

?arithmetic_and: and_expr | arithmetic_cmp

and_expr: arithmetic_cmp "AND" arithmetic_cmp

# --- Comparison

?arithmetic_cmp: cmp_equal
               | cmp_unequal
               | cmp_gte
               | cmp_lte
               | cmp_gt
               | cmp_lt
               | arithmetic_add

cmp_equal: arithmetic_add "EQUALS" arithmetic_add
cmp_unequal: arithmetic_add "NOT_EQUALS" arithmetic_add
cmp_gte: arithmetic_add "GTE" arithmetic_add
cmp_lte: arithmetic_add "LTE" arithmetic_add
cmp_gt: arithmetic_add "ANGLE_OPEN" arithmetic_add
cmp_lt: arithmetic_add "ANGLE_CLOSE" arithmetic_add

# --- Addition/Subtraction

?arithmetic_add: addition | subtraction | arithmetic_mul

addition: arithmetic_mul "PLUS" arithmetic_mul
subtraction: arithmetic_mul "MINUS" arithmetic_mul

# --- Multiplication/Division

?arithmetic_mul: multiply | divide | int_divide | modulus | arithmetic_pow

multiply: arithmetic_pow "TIMES" arithmetic_pow
divide: arithmetic_pow "DIVIDE" arithmetic_pow
int_divide: arithmetic_pow "INT_DIV" arithmetic_pow
modulus: arithmetic_pow "MOD" arithmetic_pow

# --- Exponentiation

?arithmetic_pow: raise_power | arithmetic_unary

raise_power: arithmetic_unary "POWER" arithmetic_unary

# --- Unary Operations

?arithmetic_unary: unary_negate | unary_not | atomic

unary_negate: "MINUS" atomic
unary_not: "NOT" atomic

# -- Selection

?arithmetic_select: select | select | atomic

select: atomic "SQUARE_OPEN" expression "SQUARE_CLOSE"


# -- Lexer Declarations --

%declare EXEC_ARG
%declare FLOAT
%declare NAME
%declare INTEGER
%declare QUOTED_STRING
%declare TRUE
%declare FALSE
