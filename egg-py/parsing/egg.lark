?start: top_level_expression


# -- Top Level --

?top_level_expression: write_to_file "SEMICOLON"?
                     | append_to_file "SEMICOLON"?
                     | non_atomic "SEMICOLON"?
                     | try_catch
                     | if
                     | loop
                     | define_class
                     | define_derived_class
                     | define_function
                     | continue_expr
                     | break_expr
                     | return_expr
                     | import

?non_atomic: pipeline | expression | declaration | reassignment


# -- Atomics --

?atomic: exec
       | paren_expr
       | id_or_field
       | function_pointer
       | select
       | lambda_func
       | logical_sequence
       | function_call
       | list
       | map
       | range
       | async_expr
       | literal
       | do_block

literal: QUOTED_STRING
       | INTEGER
       | FLOAT
       | TRUE
       | FALSE

?paren_expr: "PAREN_OPEN" non_atomic "PAREN_CLOSE"


# -- Identifiers and Namespaces --

?id_or_field: identifier | select_field
select_field: id_or_field "DOT" NAME
identifier: (NAME "NAMESPACE")*  NAME


# -- Function Pointers --

import: "IMPORT" QUOTED_STRING


# -- Function Pointers --

function_pointer: id_or_field "ELLIPSIS"


# -- Type Constraints --

?type: id_or_field type_generic?
type_generic: "ANGLE_OPEN" _type_generic_inner "ANGLE_CLOSE"
_type_generic_inner: type ("COMMA" type)*


# -- Variable Assignment And Declaration --

?declaration: declare_typed_variable
            | declare_untyped_variable
            | declare_typed_constant
            | declare_untyped_constant

declare_typed_variable: "VAR"? NAME "COLON" type "ASSIGN" expression
declare_untyped_variable: "VAR"? NAME "DECLARE" expression

declare_typed_constant: "CONST" NAME "COLON" type "ASSIGN" expression
declare_untyped_constant: "CONST" NAME "DECLARE" expression

?reassignment: reassign
             | plus_assign
             | minus_assign
             | times_assign
             | divide_assign
             | mod_assign
             | pipe_assign
reassign: id_or_field "ASSIGN" expression
plus_assign: id_or_field "PLUS_ASSIGN" expression
minus_assign: id_or_field "MINUS_ASSIGN" expression
times_assign: id_or_field "TIMES_ASSIGN" expression
divide_assign: id_or_field "DIVIDE_ASSIGN" expression
mod_assign: id_or_field "MOD_ASSIGN" expression
pipe_assign: id_or_field "PIPE_ASSIGN" expression


# -- Classes --

define_class: "CLASS" NAME "CURLY_OPEN" _class_inner "CURLY_CLOSE"
define_derived_class: "CLASS" NAME "COLON" id_or_field "CURLY_OPEN" _class_inner "CURLY_CLOSE"
_class_inner: class_fields class_methods
class_fields: ((class_field "COMMA")* class_field)?
?class_field: class_field_typed | class_field_untyped
class_field_typed: NAME "COLON" type ("ASSIGN" expression)?
class_field_untyped: NAME ("DECLARE" expression)?

class_methods: define_function*


# -- Lists --

list: "SQUARE_OPEN" _list_inner? "SQUARE_CLOSE"
_list_inner: expression ("COMMA" expression)*

range: "SQUARE_OPEN" _range_inner "SQUARE_CLOSE"
     | "PAREN_OPEN" _range_inner "PAREN_CLOSE"
_range_inner: expression "RANGE" expression


# -- Maps --

map: "CURLY_OPEN" _map_inner? "CURLY_CLOSE"
_map_inner: map_entry ("COMMA" map_entry)*
map_entry: expression "COLON" expression


# -- File Redirection --

write_to_file: pipeline "ANGLE_CLOSE" (EXEC_ARG | id_or_field | QUOTED_STRING)
append_to_file: pipeline "APPEND_FILE" (EXEC_ARG | id_or_field | QUOTED_STRING)


# -- If / Else --

if: "IF" atomic block elif* else?
elif: "ELSE" "IF" atomic block | "ELIF" atomic block
else: "ELSE" block


# -- Pipelines --

exec: EXEC_ARG+
?pipeline: atomic ("PIPE" atomic)+


# -- Code Blocks --

block: "CURLY_OPEN" top_level_expression* "CURLY_CLOSE"


# -- ASYNC --

async_expr: "ASYNC" (paren_expr | block)


# -- Error Handling --

try_catch: try_catch_bound | try_catch_unbound
try_catch_bound: "TRY" NAME ("COLON" type)? block "CATCH" block
try_catch_unbound: "TRY" block "CATCH" block

logical_sequence: and_sequence | or_sequence
and_sequence: atomic "SEQ_AND" atomic
or_sequence:  atomic "SEQ_OR" atomic


# -- Functions --

define_function : "FN" NAME func_arglist func_type? block

func_arglist : "PAREN_OPEN" (func_arg ("COMMA" func_arg)*)? "PAREN_CLOSE"
?func_arg: NAME (arg_type)? (arg_default)?
arg_type: "COLON" type
arg_default: "ASSIGN" expression
?func_type: "COLON" atomic

return_expr : "RETURN" expression


# -- Do Blocks --

do_block: "DO" block


# -- Lambdas --

lambda_func: "LAMBDA" (func_arglist | func_arg) "ARROW" expression
           | "LAMBDA" (func_arglist | func_arg) block


# -- Function Calls --

function_call: atomic "PAREN_OPEN" function_call_args "PAREN_CLOSE"
function_call_args: (expression ("COMMA" expression)*)?


# -- Loops --

?loop: always_loop | for | while
always_loop: "ALWAYS_LOOP" label? block
for: "FOR" NAME "IN" expression label? block
while: "WHILE" expression label? block

label: "AS" NAME

continue_expr : "CONTINUE" NAME?
break_expr : "BREAK" NAME?


# -- Arithmetic --

?expression: arithmetic_curry

# --- Currying

?arithmetic_curry: curried_func | arithmetic_or

curried_func: arithmetic_curry ("CURRY" arithmetic_or)


# --- Disjunction

?arithmetic_or: or_expr | xor_expr | arithmetic_and

or_expr: arithmetic_or "OR" arithmetic_and
xor_expr: arithmetic_or "XOR" arithmetic_and

# --- Conjunction

?arithmetic_and: and_expr | arithmetic_cmp

and_expr: arithmetic_and "AND" arithmetic_cmp

# --- Comparison

?arithmetic_cmp: comparison_chain | arithmetic_add

comparison_chain: arithmetic_add (comparison_symbol arithmetic_add)+

?comparison_symbol: "EQUALS" -> equal_to
                  | "NOT_EQUALS" -> not_equal_to
                  | "GTE" -> greater_than_or_equal_to
                  | "LTE" -> less_than_or_equal_to
                  | "ANGLE_OPEN" -> less_than
                  | "ANGLE_CLOSE" -> greater_than

# --- Addition/Subtraction

?arithmetic_add: addition | subtraction | arithmetic_mul

addition: arithmetic_add "PLUS" arithmetic_mul
subtraction: arithmetic_add "MINUS" arithmetic_mul

# --- Multiplication/Division

?arithmetic_mul: multiply | divide | int_divide | modulus | arithmetic_pow

multiply: arithmetic_mul "TIMES" arithmetic_pow
divide: arithmetic_mul "DIVIDE" arithmetic_pow
int_divide: arithmetic_mul "INT_DIV" arithmetic_pow
modulus: arithmetic_mul "MOD" arithmetic_pow

# --- Exponentiation

?arithmetic_pow: raise_power | arithmetic_unary

raise_power: arithmetic_unary "POWER" arithmetic_pow

# --- Unary Operations

?arithmetic_unary: unary_negate | unary_not | atomic

unary_negate: "MINUS" atomic
unary_not: "NOT" atomic


# -- Selection --

select: atomic "SQUARE_OPEN" _select_inner "SQUARE_CLOSE"
_select_inner: expression ("COLON" expression ("COLON" expression)?)?


# -- Lexer Declarations --

%declare EXEC_ARG
%declare FLOAT
%declare NAME
%declare INTEGER
%declare QUOTED_STRING
%declare TRUE
%declare FALSE